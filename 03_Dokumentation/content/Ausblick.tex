%!TEX root = ../dokumentation.tex
\chapter{Ausblick}\label{chap:ausblick}
Im folgenden sollen Aspekte aufgeführt und erläutert werden, welche am \ac{LIDAR} System noch verbessert oder erweitert werden können. Teilweise sind für die Aspekte bereits Materialien vorhanden oder es wurden Verschiedene Methoden recherchiert. Alle unterlagen, welche mit dem Projekt verknüpft sind, sind im Github zu finden.\\
Die Verbesserungen werden in zwei Verschiedene Bereiche geteilt. Im Hardware Teil wird darauf eingegangen, welche Punkte an der Mechanik und/oder den Elektrischen Komponenten verbessert werden kann. Im zweiten Teil, der Software wird dann darauf eingegangen, wie man das System nutzerfreundlicher gestalten könnte.  
\section{Hardware}
\subsection{Platine}
Da beim Entwurf der Platine einige Fehler passiert sind, diese sind bereits im Layout behoben und die Platine muss neu gefräst werden. Bevor dies allerdings geschieht sollte diese auch neu gelayoutet werden, da es verschiedene Optimierungsmöglichkeiten gibt. \\
Die erste Optimierungsmöglichkeit für das neue Platinenlayout ist, dass ein Zusätzlicher Pin für die Lichtschranke heraus geführt wird, damit ist die Platine wieder so flexibel einsetzbar wie gedacht. Da dann auch ein Sensor welcher mittels \ac{SPI} angesteuert wird wieder einsetzbar ist.\\
Ein größerer Aspekt welcher im neuen Platinenlayout beachtet werden sollte ist, dass der Flachbandkabelstecker zum Raspberry Pi an den Rand zum Raspberry Pi hin umpositioniert wird. Dies erleichtert die Montage / Demontage der Platine oder des Raspberry Pi's. Zudem hat der Motortreiber des Motors 1 dann ausreichend Platz nach oben um entstehende Hitze abzuführen. Außerdem sind die gesamten Pins, welche vom Flachbandkabel verdeckt werden dann einfacher zu erreichen, dies bedeutet eine einfachere Wartung des \ac{LIDAR} Systems.
\subsection{Gyrosensor}
Im ursprünglichen Konzept des \ac{LIDAR} Systems war vorgesehen, dass sich sowohl die Horizontal- als auch die Vertikalachse selbstständig Kalibrieren können. Für die Horizontalachse hat dies durch die Verwendung einer Lichtschranke reibungslos geklappt, die Vertikalachse sollte sich mittels eines Gyrosensors in Nulllage, oder jede beliebige andere Lage, bringen können. Allerdings konnte dies im Rahmen der Studienarbeit nichtmehr implementiert werden, da der Sensor in ersten Tests zu ungenau war und weitere Tests nichtmehr möglich waren.. Der Sensor \todo{Name Sensor} ist bereits vorhanden und muss lediglich getestet und implementiert werden.
\subsection{Schleifring}
Ebenfalls war im Konzept und der \ac{CAD} Zeichnung des \ac{LIDAR} Systems die Verwendung eines Schleifrings geplant, da bei Verwendung kein umdrehen nach 360° nötig ist, sondern sich das System kontinuierlich in eine Richtung drehen kann.\\
Da es bei dem Schleifring allerdings zu Lieferschwierigkeiten kam, konnte dieser im Rahmen der Studienarbeit nicht verbaut werden. Die Bauteile sind allerdings so konstruiert, dass der vorgesehene Schleifring lediglich eingebaut werden müsste. 
\subsection{Motortreiber}
Die Motortreiber welche im Rahmen der Studienarbeit verwendet wurden können maximal achtel Schritte tätigen. Wenn ein weiteres erhöhen der Messauflösung des Systems gewünscht ist, könnte man bessere Motortreiber verwenden, welche in der Lage sind sechzehntel Schritte zu tätigen. Außerdem sollte der Motortreiber des Motors 1 also der Vertikalen Achse kontrolliert werden, da wie bereits erwähnt dieser bei korrekter Ansteuerung lediglich viertel Schritte tätigt. 
\subsection{Bedienfeld}
Ein weiterer Aspekt welcher bereits teilweise vorbereitet ist, ist die anbringung eines Bedienfelds an der front des \ac{LIDAR} Systems. Die bringt den Vorteil, dass die Messung nichtmehr über einen Computer gestartet werden muss, sondern das \ac{LIDAR} System alleinstehend verwendbar ist.\\
Mögliche Elemente, welche sowohl in Hard- als auch in Software erstellt werden müssen sind:
\begin{itemize}
	\item LCD Panel zur Ausgabe der Menüoptionen und des Fortschritts
	\item Drehencoder zur navigation im Menü
	\item Anbringen der Status LED's
	\item Anbringen des Ein- \& Ausschalters des \ac{LIDAR} Systems
\end{itemize}
Zum anbringen des Bedienfelds wurden bereits Nutensteine im vorderen Teil des Rahmens eingebracht, so dass man das Bedienfeld einfach anbringen kann.

\section{Software}
Damit einige der erwähnten Hardware Implementationen möglich sind müssen auch Anpassungen an der Software vorgenommen werden.
\subsection{Steuerung mit Übergabeparameter}
Um eine noch einfachere Steuerung des Systems zu ermöglichen können in Zukunft die Klassen so umgeschrieben werden, dass die Übergabe von Parametern möglich ist.\\
Eine möglicher aufruf eines Programms könnte dann wie folgt aussehen (Listing \ref{variables_calling}). Diese Funktion soll den Motor, welcher durch den ersten Übergabeparameter festgelegt wird um die Anzahl Schritte welche vom zweiten Übergabeparameter festgelegt werden drehen. Die Richtung soll dabei durch das Vorzeichen des zweiten Übergabeparameters bestimmt werden. Dabei soll ein positives Vorzeichen eine Drehung mit dem Uhrzeigersinn und ein negatives Vorzeichen eine Drehung gegen den Uhrzeigersinn bewirken.
\begin{lstlisting}[caption={Beispiel Aufruf einer Python Funktion mit Übergabeparametern}, language={bash}, label={variables_calling}, numbers=left]
python LIDAR_Bewegen.py 1 -400
\end{lstlisting}
Um diese Funktion zu implementieren müssen allerdings die Bestehenden Funktionen überarbeitet werden. In Listing \ref{variables_function} ist ein Code Beispiel für ein Programm welches über Übergabeparameter die Motoren steuern kann. Dieses Beispiel ist allerdings noch nicht am System selbst getestet worden. 
\begin{lstlisting}[caption={Python Beispiel Funktion welche Übergabeparamenter akzeptiert und ausführt}, language={python}, label={variables_function}, numbers=left]
## Programm zum Bewegen eines Motors

#Bibliotheken
import sys

#Eigene Dateien
import Motor


# Motor 1, Nema 11
M1 = Motor.MOTOR(31,29,37,35,33)

# Motor 2, Nema 17
M2 = Motor.MOTOR(18,16,36,38,40)

if(len(sys.argv) < 3):
    print("""Aufruf wie folgt:
    python LIDAR_Bewegen.py <nummerMotor> <Schritte>
    <nummerMotor> = 1 oder 2
    <Schritte> = positiv fuer Uhrzeigersinn, negativ fuer gegen den Uhrzeigersinn
    """)
else:
    m = sys.argv[1]
    s = sys.argv[2]
    dir = True
    if(s > 0):
        dir = True
    else if(s < 0):
        dir = False
        s = s * -1
    else:
        print("Bitte Schritte angeben")

    if(m == 1):
        M1.moveMotor(dir, s, 0.001)
    else if(m == 2):
        M2.moveMotor(dir, s, 0.001)
    else:
        print("Bitte Motor angeben")

\end{lstlisting}
Um die gewünschte Funktion zu implementieren ist die Bibliothek 'sys' sehr wichtig, denn diese Stellt die übergebenen Werte in einem Array zur Verfügung. Danach ist das Programm recht einfach aufgebaut, da in Zeile 7 - 14 die Motorklasse importiert und die beiden Motoren Initialisiert werden. Bevor mit dem eigentlichen ausführen des Programms, bzw. der Bewegung des Motors begonnen wird, wird überprüft ob mindestens 2 Werte übergeben wurden. Falls nicht wird eine Ausgabe darauf hinweißen und die Verwendung erläutern. \\
Anschließend wird ab Zeile 23 damit begonnen die übergebenen Werte in lokale Variablen zu übernehmen und die angegebene Richtung, welche beim Aufrufen durch das Vorzeichen des zweiten Parameters festgelegt wird, zu prüfen. Danach wird nur noch die Bekannte Funktion der Motor Klasse zum bewegen des Motors aufgerufen.

\subsection{Bedienfeld Statusausgabe und Steuerung}
Um ein Bedienfeld zu realisieren muss gegebenenfalls ein Komplettes Menü erstellt werden, durch welches die verschiedenen Funktionen aufrufbar sind. Bei der Implementierung gilt es darauf zu achten, dass die Objektorientierte Programmierung beibehalten wird und die Möglichkeit weitere Funktionen zu implementieren erhalten bleibt.\\
Um heraus zu finden wie weit eine Messung fortgeschritten ist, muss lediglich im Programmablauf beobachtet werden, wie viele der Festgelegten Messpunkte bereits aufgenommen wurden. Dies Kann relativ einfach über die beiden Zähler Variablen der while Schleifen realisiert werden. 
\todo{Recherche Python console Ladebalken und Pseudocode erstellen} 

\subsection{Webinterface}
Die selbe Steuerung welche über das Bedienfeld direkt am System möglich ist, kann auch am PC in einem ansprechenden \ac{GUI} möglich sein. Dazu ist die Idee, dies mittels einem Webinterface zu realisieren. Der Raspberry Pi könnte dazu ein eigenständiges \ac{WLAN} verwalten. Für die Darstellung der Website kann beispielsweiße ein NodeJS Server auf dem Raspberry Pi aufgesetzt werden. Um von javascript anfragen an den Server, bzw. Python zu senden kann die Bibliothek Flask verwendet werden. Im folgenden wird auf die Ideen zu den einzelnen Komponenten näher eingegangen. 
\subsubsection{\ac{WLAN} auf dem Raspberry Pi einrichten}
Da im Projekt ein Raspberry Pi der dritten Generation verwendet wurde, besitzt dieser durch den verbauten \ac{WLAN}-Chip die Möglichkeit ein eigenes \ac{WLAN}-Netzwerk zu erstellen und verwalten. https://www.raspberrypi.org/products/raspberry-pi-3-model-b/ 
Durch einige Änderungen in den Netzwerkeinstellungen lässt sich diese Funktion nutzen.
Zunächst müssen dafür die Packages zur Verwaltung der Zugriffe auf das Netzwerk installiert werden.
\begin{lstlisting}[caption={Installation dnsmasq hostapd}, language={bash}, numbers=left]
sudo apt-get install dnsmasq hostapd
\end{lstlisting}
Diese neu installierten Packages müssen anschließend auch konfiguriert werden. Dazu wird folgende Datei aufgerufen und durch eine Zeile ergänzt.
\begin{lstlisting}[caption={Konfiguration DHCP Server}, language={bash}, numbers=left]
Sudo nano /etc/dhcpcd.conf
\end{lstlisting}
Wird ergänzt durch
\begin{lstlisting}[caption={Konfiguration DHCP Server}, language={bash}, numbers=left]
Denyinterfaces wlan0
\end{lstlisting}
Damit der Raspberry Pi dann auch als Bereitsteller eines Netzwerks erkannt werden kann und immer wieder wird bekommt der Raspberry Pi eine Statische \ac{IP}-Adresse. 
\begin{lstlisting}[caption={Konfiguration Interfaces}, language={bash}, numbers=left]
Sudo nano /etc/network/interfaces
\end{lstlisting}
Wird dabei um mehrere Zeilen, welche zum Einstellen der Statischen \ac{IP}-Adresse dienen ergänzt.
\begin{lstlisting}[caption={Konfiguration Interfaces}, language={bash}, numbers=left]
allow-hotplug wlan0
iface wlan0 inet static
address 192.168.0.1
netmask 255.255.255.0
network 192.168.0.0
broadcast 192.168.0.255
\end{lstlisting}
Anschließend muss der dhcpcd client und der \ac{WLAN}-Chip neugestartet werden.
\begin{lstlisting}[caption={Konfiguration Interfaces}, language={bash}, numbers=left]
Sudo service dhcpcd restart
sudo ifdown wlan0; sudo ifup wlan0
\end{lstlisting}
Danach kann das Package, hostapt ebenfalls konfiguriert werden. 
\begin{lstlisting}[caption={Konfiguration Hostapd}, language={bash}, numbers=left]
Sudo nano /etc/hostapd/hostapd.conf
\end{lstlisting}
Dazu müssen folgende Zeilen in diese Datei geschrieben werden.
\begin{lstlisting}[caption={Konfiguration Hostapd}, language={bash}, numbers=left]
# Schnittstelle und Treiber
interface=wlan0
driver=nl80211
# WLAN-Konfiguration
ssid=LIDAR_WLAN
channel=1
hw_mode=g
ieee80211n=1
ieee80211d=1
country_code=DE
wmm_enabled=1
# WLAN-Verschluesselung
auth_algs=1
wpa=2
wpa_key_mgmt=WPA-PSK
rsn_pairwise=CCMP
wpa_passphrase=
\end{lstlisting}
Anschließend muss lediglich eine weitere Zeile ergänzt werden, damit die Konfiguration vollständig ist.
\begin{lstlisting}[caption={Konfiguration Hostapd}, language={bash}, numbers=left]
Sudo nano /etc/default/hostapd
\end{lstlisting}
Dort muss folgende Zeile ergänzt werden
\begin{lstlisting}[caption={Konfiguration Hostapd}, language={bash}, numbers=left]
DAEMON_CONF="/etc/hostapd/hostapd.conf"
\end{lstlisting}
Dann kann das letzte Package dnsmasq eingerichtet werden. Dieses Package ist dafür zuständig, die \ac{IP}-Adressen an die Nutzer des \ac{WLAN} zu verteilen.
Da die Grundkonfiguration von dnsmasq sehr viele Einstellungen beinhaltet sollte diese abgespeichert werden bevor eine neue eigene Konfigurationsdatei erstellt wird.
\begin{lstlisting}[caption={Konfiguration dnsmasq}, language={bash}, numbers=left]
sudo mv /etc/dnsmasq.conf /etc/dnsmasq.conf_alt
sudo nano /etc/dnsmasq.conf
\end{lstlisting}
Anschließend können folgende Zeilen in die neue Konfigurationsdatei eingetragen werden.
\begin{lstlisting}[caption={Konfiguration dnsmasq}, language={bash}, numbers=left]
Interface=wlan0
no-dhcp-interface=eth0
listen-address=192.168.0.1
bind-interfaces
server=8.8.8.8
dhcp-range=192.168.0.50,192.168.0.150,240h
\end{lstlisting}
Damit wenn der Raspberry Pi über \ac{LAN} an ein Netzwerk angeschlossen ist auch ein Internetzugriff stattfinden kann müssen die Pakete auch weitergeleitet werden, dazu sind weitere Einstellungen notwendig.
\begin{lstlisting}[caption={Konfiguration IPV4}, language={bash}, numbers=left]
Sudo nano /etc/sysctl.conf
\end{lstlisting}
Muss dazu mit der zeile
\begin{lstlisting}[caption={Konfiguration IPV4}, language={bash}, numbers=left]
Net.ipv4.ip_forward=1
\end{lstlisting}
Danach muss der Raspberry Pi Neu gestartet werden.
Anschließend müssen folgende Zeilen für die Weiterleitung Ausgeführt werden.
\begin{lstlisting}[caption={Konfiguration IPV4}, language={bash}, numbers=left]
sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
sudo iptables -A FORWARD -i eth0 -o wlan0 -m state -state RELATED,ESTABLISHED -j ACCEPT
sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT
sudo sh -c "iptables-save > /etc/iptables.ipv4.nat"
\end{lstlisting}
Zuletzt muss noch eine Datei geändert werden.
\begin{lstlisting}[caption={Konfiguration IPV4}, language={bash}, numbers=left]
Sudo nano /etc/rc.local
\end{lstlisting}
Und folgende Zeile eingefügt werden
\begin{lstlisting}[caption={Konfiguration IPV4}, language={bash}, numbers=left]
Iptables-restore < /etc/iptables.ipv4.nat
\end{lstlisting}
Dann kann final der Hostapd und die dnsmasq gestartet werden.
\begin{lstlisting}[caption={Starten der neu installierten Packages}, language={bash}, numbers=left]
Sudo service hostapd start
sudo service dnsmasq start
Suod reboot
\end{lstlisting}
Nach dem Neustart des Raspberry Pi sollte ein \ac{WLAN} sichtbar sein um man sollte sich mit diesem Verbinden können. https://www.elektronik-kompendium.de/sites/raspberry-pi/2002171.htm https://www.randombrick.de/raspberry-pi-als-wlan-access-point-nutzen/ 


\subsubsection{NodeJS Server auf dem Raspberry Pi einrichten}
Um einen Webserver auf dem Raspberry Pi einrichten zu können wird NodeJS verwendet. Auch dies muss erst installiert und eingerichtet werden. 
\begin{lstlisting}[caption={Installation NodeJS}, language={bash}, numbers=left]
curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -
sudo apt-get install -y nodejs
\end{lstlisting}
Ob die Installation erfolgreich war lässt sich mit folgendem Befehl überprüfen.
\begin{lstlisting}[caption={Installation NodeJS}, language={bash}, numbers=left]
node -v
\end{lstlisting}
%https://www.w3schools.com/nodejs/nodejs_raspberrypi.asp 

\subsubsection{Flask in Javascript und Python verwenden}
Flask ist ein Python Microframework, welches es ermöglicht verschiedene Routen direkt in Python über einen Webserver anzusprechen. Dies gibt in diesem Fall die Möglichkeit aus dem NodeJS Server heraus Python Programme zu starten. 
Um Flask zu verwenden muss dieses Natürlich zunächst Installiert werden. Dazu muss ein Ordner angelegt sein und in diesem Ordner eine Virtuelle Umgebung erstellt werden. 
\begin{lstlisting}[caption={Installation Flask}, language={bash}, numbers=left]
mkdir LIDAR
cd LIDAR
python3 -m venv venv
. venv/bin/activate
\end{lstlisting}
Anschließend kann Flask Installiert werden.
\begin{lstlisting}[caption={Installation Flask}, language={bash}, numbers=left]
Sudo pip install Flask
\end{lstlisting}
Nun kann eine Rote hinzugefügt werden, welche man dann, wenn der Flask Server gestartet ist über eine Route aufrufen kann. 
Im Fall dieses Projektes eignet sich Flask dazu die bereits vorhandenen Dateien aufrufen zu lassen. Die zugehörige Datei dazu könnte wie Folgt aussehen.
\begin{lstlisting}[caption={Flask Beispielprogram}, language={python}, numbers=left]
From flask import Flask
import subprocess
app=Flask(__name__)

@app.route('/movemotor1/<int: steps>')
def moveMotor1(steps):
	subprocess.run(["python", "LIDAR_Bewegen.py", "1", str(steps)])
	return;
@app.route('/movemotor2/<int: steps>')
def moveMotor2(steps):
	subprocess.run(["python", "LIDAR_Bewegen.py", "2", str(steps)])
	return;

\end{lstlisting}
Dies ist ein ungetesteter Beispielcode um die neu entworfene Funktion zum Bewegen der Motoren aufzurufen. Dabei ist es möglich über zwei verschiedene Routen die beiden Motoren anzusprechen und über einen Zusatz in der Route kann die Anzahl der Schritte angegeben werden. 
http://flask.pocoo.org 



